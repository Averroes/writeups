/* This file has been generated by the Hex-Rays decompiler.
   Copyright (c) 2007-2015 Hex-Rays <info@hex-rays.com>

   Detected compiler: GNU C++
*/

#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int init_proc();
// int setsockopt(int fd, int level, int optname, const void *optval, socklen_t optlen);
// ssize_t write(int fd, const void *buf, size_t n);
// int chdir(const char *path);
// uint16_t htons(uint16_t hostshort);
// uint32_t htonl(uint32_t hostlong);
// unsigned int alarm(unsigned int seconds);
// int close(int fd);
// int setgroups(size_t n, const __gid_t *groups);
// ssize_t read(int fd, void *buf, size_t nbytes);
// struct passwd *getpwnam(const char *name);
// int fprintf(FILE *stream, const char *format, ...);
// int sigemptyset(sigset_t *set);
// int __gmon_start__(void); weak
// int listen(int fd, int n);
// int bind(int fd, const struct sockaddr *addr, socklen_t len);
// int setgid(__gid_t gid);
// void perror(const char *s);
// void bzero(void *s, size_t n);
// int accept(int fd, struct sockaddr *addr, socklen_t *addr_len);
// int atoi(const char *nptr);
// int sprintf(char *s, const char *format, ...);
// void __noreturn exit(int status);
// int setuid(__uid_t uid);
// void *dlsym(void *handle, const char *name);
// __pid_t fork(void);
// int socket(int domain, int type, int protocol);
int deregister_tm_clones();
int register_tm_clones();
int _do_global_dtors_aux();
int frame_dummy();
signed __int64 __fastcall priv(const char *a1);
__int64 __fastcall func1(int a1);
__int64 __fastcall func2(int a1);
ssize_t __fastcall menu(int a1);
int __cdecl main(int argc, const char **argv, const char **envp);
void __fastcall _libc_csu_init(unsigned int a1, __int64 a2, __int64 a3);
void term_proc();

//-------------------------------------------------------------------------
// Data declarations

__int64 (__fastcall *_frame_dummy_init_array_entry[2])() = { &frame_dummy, &_do_global_dtors_aux }; // weak
__int64 (__fastcall *_do_global_dtors_aux_fini_array_entry)() = &_do_global_dtors_aux; // weak
FILE *_bss_start; // idb
char completed_6973; // weak
// extern _UNKNOWN _gmon_start__; weak


//----- (0000000000400A98) ----------------------------------------------------
int init_proc()
{
  void *v0; // rax@1

  v0 = &_gmon_start__;
  if ( &_gmon_start__ )
    LODWORD(v0) = __gmon_start__();
  return (unsigned __int64)v0;
}
// 400BB0: using guessed type int __gmon_start__(void);

//----- (0000000000400C90) ----------------------------------------------------
#error "400C96: positive sp value has been found (funcsize=3)"

//----- (0000000000400CC0) ----------------------------------------------------
int deregister_tm_clones()
{
  signed __int64 v0; // rax@1

  v0 = 6299919LL - (_QWORD)&_bss_start;
  if ( (unsigned __int64)(6299919LL - (_QWORD)&_bss_start) > 0xE )
    LODWORD(v0) = 0;
  return v0;
}

//----- (0000000000400CF0) ----------------------------------------------------
int register_tm_clones()
{
  return 0;
}

//----- (0000000000400D30) ----------------------------------------------------
int _do_global_dtors_aux()
{
  int result; // eax@2

  if ( !completed_6973 )
  {
    result = deregister_tm_clones();
    completed_6973 = 1;
  }
  return result;
}
// 602110: using guessed type char completed_6973;

//----- (0000000000400D50) ----------------------------------------------------
int frame_dummy()
{
  return register_tm_clones();
}
// 400D50: could not find valid save-restore pair for rbp

//----- (0000000000400D7D) ----------------------------------------------------
signed __int64 __fastcall priv(const char *a1)
{
  signed __int64 result; // rax@2
  struct passwd *v2; // [sp+18h] [bp-8h]@1

  v2 = getpwnam(a1);
  if ( v2 )
  {
    if ( chdir(v2->pw_dir) )
    {
      perror("chdir");
      result = 1LL;
    }
    else if ( setgroups(0LL, 0LL) )
    {
      perror("setgroups");
      result = 1LL;
    }
    else if ( setgid(v2->pw_gid) )
    {
      perror("setgid");
      result = 1LL;
    }
    else if ( setuid(v2->pw_uid) )
    {
      perror("setuid");
      result = 1LL;
    }
    else
    {
      result = 0LL;
    }
  }
  else
  {
    fprintf(_bss_start, "User %s does not exist\n", a1);
    result = 1LL;
  }
  return result;
}

//----- (0000000000400E62) ----------------------------------------------------
__int64 __fastcall func1(int a1)
{
  char *v1; // ST18_8@1
  char s; // [sp+20h] [bp-40h]@1
  __int64 v4; // [sp+58h] [bp-8h]@1

  v4 = *MK_FP(__FS__, 40LL);
  v1 = (char *)dlsym((void *)0xFFFFFFFF, "puts");
  write(a1, "Reference:", 0xAuLL);
  sprintf(&s, "%p\n", v1 - 1280);
  write(a1, &s, 0xFuLL);
  return *MK_FP(__FS__, 40LL) ^ v4;
}

//----- (0000000000400EF2) ----------------------------------------------------
__int64 __fastcall func2(int a1)
{
  char s; // [sp+10h] [bp-140h]@1
  __int64 v3; // [sp+148h] [bp-8h]@1

  v3 = *MK_FP(__FS__, 40LL);
  bzero(&s, 0x12CuLL);
  write(a1, "Time to test your exploit...\n", 0x1DuLL);
  write(a1, ">", 1uLL);
  read(a1, &s, 0x1CCuLL);
  write(a1, &s, 0x144uLL);
  return *MK_FP(__FS__, 40LL) ^ v3;
}

//----- (0000000000400FA2) ----------------------------------------------------
ssize_t __fastcall menu(int a1)
{
  char buf; // [sp+10h] [bp-10h]@1

  while ( 1 )
  {
    while ( 1 )
    {
      write(a1, "-Tutorial-\n", 0xBuLL);
      write(a1, "1.Manual\n", 9uLL);
      write(a1, "2.Practice\n", 0xBuLL);
      write(a1, "3.Quit\n", 7uLL);
      write(a1, ">", 1uLL);
      read(a1, &buf, 2uLL);
      if ( buf != 50 )
        break;
      func2(a1);
    }
    if ( buf == 51 )
      break;
    if ( buf == 49 )
      func1(a1);
    else
      write(a1, "unknown option.\n", 0x10uLL);
  }
  return write(a1, "You still did not solve my challenge.\n", 0x26uLL);
}

//----- (0000000000401087) ----------------------------------------------------
int __cdecl __noreturn main(int argc, const char **argv, const char **envp)
{
  uint16_t v3; // ax@7
  char v4; // [sp+14h] [bp-4Ch]@1
  int optval; // [sp+18h] [bp-48h]@1
  socklen_t addr_len; // [sp+1Ch] [bp-44h]@13
  int fd; // [sp+20h] [bp-40h]@1
  int v8; // [sp+24h] [bp-3Ch]@14
  int v9; // [sp+28h] [bp-38h]@17
  int v10; // [sp+2Ch] [bp-34h]@20
  __int16 s; // [sp+30h] [bp-30h]@4
  uint16_t v12; // [sp+32h] [bp-2Eh]@7
  uint32_t v13; // [sp+34h] [bp-2Ch]@7
  struct sockaddr addr; // [sp+40h] [bp-20h]@14
  __int64 v15; // [sp+58h] [bp-8h]@1

  v15 = *MK_FP(__FS__, 40LL);
  optval = 1;
  sigemptyset((sigset_t *)&v4);
  fd = socket(2, 1, 0);
  if ( fd == -1 )
  {
    perror("socket");
    exit(-1);
  }
  bzero(&s, 0x10uLL);
  if ( setsockopt(fd, 1, 2, &optval, 4u) == -1 )
  {
    perror("setsocket");
    exit(-1);
  }
  s = 2;
  v13 = htonl(0);
  v3 = atoi(argv[1]);
  v12 = htons(v3);
  if ( bind(fd, (const struct sockaddr *)&s, 0x10u) == -1 )
  {
    perror("bind");
    exit(-1);
  }
  if ( listen(fd, 20) == -1 )
  {
    perror("listen");
    exit(-1);
  }
  addr_len = 16;
  while ( 1 )
  {
    v8 = accept(fd, &addr, &addr_len);
    if ( v8 < 0 )
      break;
    v9 = fork();
    if ( v9 == -1 )
    {
      perror("fork");
      close(v8);
    }
    if ( v9 )
    {
      close(v8);
    }
    else
    {
      alarm(0xFu);
      close(fd);
      v10 = priv("tutorial");
      if ( !v10 )
      {
        menu(v8);
        close(v8);
        exit(0);
      }
    }
  }
  perror("accept");
  exit(1);
}

//----- (0000000000401280) ----------------------------------------------------
void __fastcall _libc_csu_init(unsigned int a1, __int64 a2, __int64 a3)
{
  __int64 v3; // r13@1
  __int64 v4; // rbx@1
  signed __int64 v5; // rbp@1

  v3 = a3;
  v4 = 0LL;
  v5 = &_do_global_dtors_aux_fini_array_entry - _frame_dummy_init_array_entry;
  init_proc();
  if ( v5 )
  {
    do
      ((void (__fastcall *)(_QWORD, __int64, __int64))_frame_dummy_init_array_entry[v4++])(a1, a2, v3);
    while ( v4 != v5 );
  }
}
// 601E00: using guessed type __int64 (__fastcall *_frame_dummy_init_array_entry[2])();
// 601E08: using guessed type __int64 (__fastcall *_do_global_dtors_aux_fini_array_entry)();

//----- (00000000004012F4) ----------------------------------------------------
void term_proc()
{
  ;
}

#error "There were 1 decompilation failure(s) on 13 function(s)"
